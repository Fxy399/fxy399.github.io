---
title: 线程池的工作原理
date: 2023-10-16 17:25:36
tags: 多线程
description: 线程池的工作原理以及源码解析
---
# 线程池相关概念总览

本文主要侧重于从源码层面学习jdk8中线程池的实现原理。

## 池的思想

因为线程资源十分宝贵，并且每次创建和销毁线程的开销都比较大，另一方面，如果创建太多的线程，也会消耗系统大量资源，降低系统吞吐量，甚至导致服务不可用。为了解决这些问题，提出一种基于池化思想管理和使用线程的机制，这就是我们的线程池。

线程池的核心思想就是能做到线程复用，线程池中的线程执行完不会销毁，而是存留在内存中，等待执行下一个线程。

## 线程池的几个关键属性

* corePoolSize： 核心线程数
* maximumPoolSize：最大线程数，线程池允许创建的最大线程数
* workQueue： 任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）
* keepAliveTime：空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 `allowCoreThreadTimeOut(true)`使核心线程数内的线程也可以被回收。
* ThreadFactory：线程工厂，包装了许多针对线程的方法，比如可以设置线程名，方便调试
* rejectedExecutionHandler：拒绝策略

## 线程池的工作流程

线程池实际上采用的是：生产者-消费者模型，如下图:

![img](线程池.awebp)

线程池的工作流程：

* 如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；

* 如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；

* 如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略，对超出数量的任务进行处理。
* 如果线程数超过 corePoolSize，并且有线程的空闲时间超过了空闲线程的存活时间，会执行关闭这些线程的操作。

看完上面线程池的工作流程，有没有觉得很熟悉呢，是不是马上联想到一个非常经典的设计模型：**生产-消费者模型**。

## 线程池状态管理

线程池的状态管理很特别，Doug Lea 采用了一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数，并且通过位运算来对状态进行管理。

下面是线程池几种状态：

|    状态    | 高三位值 |                             说明                             |
| :--------: | :------: | :----------------------------------------------------------: |
|  RUNNING   |   111    | 运行状态，线程池被创建后的初始状态，能接受新提交的任务，也能处理阻塞队列中的任务 |
|  SHUTDOWN  |   000    |  关闭状态，不再接收新提交的任务，但可以处理阻塞队列中的任务  |
|    STOP    |   001    | 停止状态，会中断正在处理的线程，不能接受新提交的任务，也不会处理阻塞队列中的任务 |
|  TIDYING   |   010    | 所有任务都已经终止，有效工作线程为0，并且当任务状态转到TIDYING时，运行termination() 钩子方法 |
| TERMINATED |   011    |                   终止状态，线程池彻底终止                   |

接下来我们来看源码：

```java
//ctl (线程池控制状态)是原子整型的，这意味这对它进行的操作具有原子性
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数
// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的
private static final int COUNT_BITS = Integer.SIZE - 3;

// 000 11111111111111111111111111111
// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911
// 以我们现在计算机的实际情况，这个数量还是够用的
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// 我们说了，线程池的状态存放在高 3 位中
// 运算结果为 111跟29个0：111 00000000000000000000000000000
private static final int RUNNING    = -1 << COUNT_BITS;
// 000 00000000000000000000000000000
private static final int SHUTDOWN   =  0 << COUNT_BITS;
// 001 00000000000000000000000000000
private static final int STOP       =  1 << COUNT_BITS;
// 010 00000000000000000000000000000
private static final int TIDYING    =  2 << COUNT_BITS;
// 011 00000000000000000000000000000
private static final int TERMINATED =  3 << COUNT_BITS;

// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数
private static int workerCountOf(int c)  { return c & CAPACITY; }

/// rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，通过或运算生成 ctl 值
private static int ctlOf(int rs, int wc) { return rs | wc; }

/*
 * Bit field accessors that don't require unpacking ctl.
 * These depend on the bit layout and on workerCount being never negative.
 */

private static boolean runStateLessThan(int c, int s) {
    return c < s;
}

private static boolean runStateAtLeast(int c, int s) {
    return c >= s;
}

private static boolean isRunning(int c) {
    return c < SHUTDOWN;
}
```

# 源码分析

前面了解了线程池的相关概念，接下来我们从源码入手分析线程池的实现过程。

## 类关系概览

![img](线程池继承关系.png)

线程池的继承结构分析：线程池继承结构的最顶层为 Executor 接口类，该类仅有一个 execute(Runnable runnable) 方法。

ExecutorService 也是接口路类，继承了 Executor，并在此基础上扩充了许多接口方法，所以一般来说我们会使用这个接口类。

接下来是 AbstractExecutorService 抽象类，该类直接实现了 ExecutorService 接口，提供了非常有用的基础方法供子类直接调用。

最后就是大名鼎鼎的 ThreadPoolExecutor，这个类实现了关于线程池管理的丰富功能。

### AbstractExecutorService 抽象类

我们先从 AbstractExecutorService 开始，该抽象类直接实现了 ExecutorService 接口类中的方法，主要实现了线程池的基本功能，比如提交任务，获取结果，关闭线程池等。

以下是 AbstractExecutorService 的源码解析：

```java
public abstract class AbstractExecutorService implements ExecutorService {
    
    /**
     * 这两个方法将 Runnable 和 Callable 对象转换为 FutureTask 对象
     */
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
    
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }
    
    /**
     * 提交任务
     */
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        // 1. 将任务包装成 FutureTask
        RunnableFuture<T> ftask = newTaskFor(task);
        //将任务提交给 execute 方法，由具体的实现类实现
        execute(ftask);
        return ftask;
    }
    
    //接下来是一些 invoke 方法，我并不打算详细叙述，这些方法作用是提交 tasks 任务集合，但是这些方法并不是直接执行线程的方法，他们都只是调用 线程池的 execute() 方法
    
   <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException {
       ......
   }
}
```

### 线程提交原理

我们从 AbstractExecutorService  的代码中可以看出例如 submit，invokeAny，invokeAll 等方法，他们并不是直接开启线程来执行任务，而是都在方法内部调用了 execute 方法， 接下来我们就进入 ThreadPoolExecutor 类中，看看神秘的 execute 方法是如何执行线程池任务的。

#### execute 方法提交任务

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        //如果运行的线程少于 corePoolSize，直接通过 addWorker() 方法添加一个 worker 来执行任务
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                // addWorker() 成功，直接返回
                return;
            c = ctl.get();
        }
        //到这一步说明，要么当前线程数大于核心线程数，要么刚刚 addWorker() 失败
        
        //如果线程处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // 双重检查，因为从上次检查到进入此方法，线程池可能已成为SHUTDOWN状态，那么把已经入队的任务移除，并且执行拒绝策略
            if (! isRunning(recheck) && remove(command))
                reject(command);
            //执行到这里说明线程是 RUNNING 状态，判断如果当前线程数等于0，那么新加一个worker线程执行任务
            //担保机制,保证线程池在 RUNNING 状态下起码有一个线程在工作
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //执行到这里说明队列已满或者线程不是 RUNNING 状态，或者等待队列已满
        //再次执行 addWorker 创建新线程，如果不成功，则执行拒绝策略
        else if (!addWorker(command, false))
            //如果添加 worker 失败，代表线程数超过 maximumPoolSize 或线程池已经关闭，则直接执行拒绝策略
            reject(command);
    }
}
```

以上是 execute 方法的实现，我们可以得知该方法属于线程池任务提交的主干逻辑：

#### 线程创建时机

1. 如果运行的线程数少于 corePoolSize，直接调用 addWorker() 方法创建工作线程
2. 如果工作线程大于等于 corePoolSize 或者前面 addWorker() 失败则需要将任务加入队列中等待，加入成功之后还会做一层双重校验，如果线程状态改变则将已经入队的任务移除。
3. 如果线程池已经不属于 RUNNING 状态，或者队列已满，再次执行 addWorker() 方法创建线程，如果创建失败，代表线程数已经超过 maximumPoolSize，则直接执行拒绝策略。

#### addWorker 方法提交线程

我们从 execute 方法中得知 addWorker 方法的目的为创建线程，添加到线程池。

```java
// firstTask 参数是被提交的任务
//core 参数意思是：true-以 corePoolSize 核心线程数作为线程创建的限制，如果线程数超过核心线程数则不创建新线程
//false-以 maximumPoolSize 作为线程创建的界限
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        //目的：
        //当状态大于 SHUTDOWN 时，不允许创建新线程
        //当线程池处于 SHUTDOWN 状态时，如果 firstTask 为空，并且 workQueue 不为空，那么是允许创建 worker 线程的。
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            //如果线程数量超过阈值，不创建新线程，返回 false
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //尝试给工作线程+1,如果失败表示同时有其他线程正在创建,如果成功则跳过循环准备创建线程。
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            //如果线程池状态不一致,重试
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        //【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】
        w = new Worker(firstTask);
        // 将新创建的 worker 中的线程赋值给 t
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            // 加互斥锁，要添加 worker 了
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
				
                //线程池状态检查
                //判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    //预检查，如果线程开启之前就已经存活，则直接报错
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    //将新建的 Worker 添加到线程池中
                    workers.add(w);
                    //更新最大线程数量
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    // 添加标记置为 true
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 添加成功就【启动线程执行任务】
            if (workerAdded) {
                t.start();
                // 运行标记置为 true
                workerStarted = true;
            }
        }
    } finally {
        //如果线程启动失败，则启动清理线程
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

从以上 execute，addWorker 方法中，我们得知线程池如何提交任务以及创建线程。

### Worker线程创建

从上面 execute 方法的代码中看到，线程池通过 addWorker 来创建线程，接下来我们对 Worker 类以及该 addWorker 方法进行分析。

Worker 作为 ThreadPoolExecutor 线程池的内部类，顾名思义，worker 是工人，Doug Lea 把线程包装成 Worker，由  Worker 来真正执行任务。

我们直接分析 Worker 类的代码：

```java
//Worker 继承自抽象类 AbstractQueuedSynchronizer，AQS 在并发中的出镜率非常高，写少量代码就能实现自己需要的同步方式，后边有时间我再研究下。
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable {
    /**  
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */
    private static final long serialVersionUID = 6138294804551838833L;

    //Worker 内部封装的工作线程
    final Thread thread;
    //线程执行的第一个任务
    Runnable firstTask;
    //线程完成的任务数
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        // 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁
        setState(-1);
        // firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务
        this.firstTask = firstTask;
         // 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()
        this.thread = getThreadFactory().newThread(this);
    }

    // 这里调用了外部类的 runWorker 方法
    public void run() {
        runWorker(this);
    }
    ......
}
```

Work 构造类会直接使用线程池创建一个 worker 线程，该线程的 run 方法会直接调用 线程池的 runWorker 方法。

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    //获取worker的 firstTask
    Runnable task = w.firstTask;
    //引用置空，防止复用线程时重复执行该任务
    w.firstTask = null;
    w.unlock(); // 允许线程中断
    boolean completedAbruptly = true;
    try {
        // firstTask 不是 null 就直接运行，否则去 queue 中获取任务
        while (task != null || (task = getTask()) != null) {
            // worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】
            w.lock();
            // 如果线程池状态大于等于 STOP，那么意味着该线程也要中断
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                //钩子方法，执行任务之前调用
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    //到这里终于开始执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                //置空 task，使 getTask 获取下一个任务
                task = null;
                //已完成的任务数量+1
                w.completedTasks++;
                // 释放掉 worker 的独占锁
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //进入这里说明已经没有任务需要执行或者执行过程中抛出异常，需要关闭线程
        processWorkerExit(w, completedAbruptly);
    }
}

//接下来看 getTask 方法是如何获取任务的
//此方法主要任务是:
//1. 从阻塞队列中获取任务
//2. 如果当前线程空闲时间超过 keepAliveTime 就会被回收
private Runnable getTask() {
    //超时标记
    boolean timedOut = false;

    for (;;) {
        //获取线程当前状态
        int c = ctl.get();
        int rs = runStateOf(c);

        // 根据线程池状态以及等待任务数量判断是否需要返回null
        //1. rs == SHUTDOWN && workQueue.isEmpty() 当线程池 SHUTDOWN 并且队列为空的时候直接返回 null
        //2. rs >= STOP 线程池状态大于等于 STOP 直接返回 null
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            //CAS 操作，减少工作线程数
            decrementWorkerCount();
            return null;
        }

        //获取线程池中的线程数量
        int wc = workerCountOf(c);

        // 判断当前线程是否需要超时被回收，判断条件为：允许回收核心线程 或者 线程数超过核心线程数
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        //根据线程数量/是否需要超时回收/是否已经超时判断是否返回null
        //线程数量超过核心线程数，返回null
        //允许回收核心线程 或者 线程数超过核心线程数，并且已经超时，返回 null
        if ((wc > maximumPoolSize || (timed && timedOut))
            //满足以上任一条件，并且线程数大于1，并且队列为空时
            && (wc > 1 || workQueue.isEmpty())) {
            //CAS 操作，减少工作线程数 并返回空
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
        
        // 从队列中获取任务，有下面两种方法
        // timed为true, 调用超时方法poll获取任务，如果等待超时则返回 null
        // timed为false,调用阻塞方法take获取,如果队列中没有任务则一直阻塞等待
        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            //获取任务为 null 说明超时了，将超时标记设置为 true，进入下一次循环，就可以销毁这个线程了
            timedOut = true;
        } catch (InterruptedException retry) {
            // 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务
            // 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null
            timedOut = false;
        }
    }
}

// processWorkerExit 方法是如何退出线程的
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    if (completedAbruptly)
        //工作线程-1,cas操作
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    // 加锁
    mainLock.lock();
    try {
        // 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount
        completedTaskCount += w.completedTasks;
        // 将 worker 从线程池中移除
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    // 尝试停止线程，唤醒下一个线程
    tryTerminate();

    int c = ctl.get();
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        addWorker(null, false);
    }
}
```

我们可以看到 Worker 实际就是一个工作线程，其被包装起来，主要负担的工作为：执行任务，维护等待队列，从等待队列中获取任务并执行，说到这里，是不是觉得 Worker 的功能特别熟悉，它在生产-消费模型里就是一个消费者角色。

至此，线程池的主要工作原理以及重点源码已经分析完成。












