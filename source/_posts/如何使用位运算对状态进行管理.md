---
title: "如何使用位运算对状态进行管理"
date: 2020-09-29 18:26:26
tags: 位运算
description: 学习使用简单与、或、异或等位运算进行状态管理
---
# 位运算的数据选择
位运算的数据必须为2的次幂，并且转换为二进制之后都只有一个为位为1，其他都是0。

为了能直观展示位运算如何实现对状态的管理，我们先来定义一组状态:

``` java
public statuc final int STATUS_DEFAULT = 0;
public static final int STATUS_OPTIMISTIC = 1;
public static final int STATUS_OPEN = 2;
public static final int STATUS_CLOSE = 4;
```

# 位运算实现状态处理逻辑
**状态处理中常用的几个位运算:**

1. &(与运算)   : 只有当两个数据全部为 ture 时结果才为 true
2. |(或运算)   : 只要两个数据中有一个为 true，结果就为 true
3. ^(异或运算) : 只要两个数据互不相同，则结果为 true

## 保存状态
>保存状态使用 |(或运算)

**保存状态的运算**:
```
private static int currentStatus = STATUS_DEFAULT; //此变量存储状态
currentStauts |= STATUS_OPEN; //或运算保存状态
```
**或运算过程**:
```
00000000
00000010
---------
00000010
```

由于或运算的计算逻辑为只要两位中有一个为1，结果就会为1，所以会将状态数中为1的位存进结果里。

##  判断是否有某个状态
> 判断是否有某个状态使用 &(与运算) 操作

**判断是否有某个状态的运算**:
```
private static int currentStatus = STATUS_DEFAULT; //此变量存储状态
currentStauts |= STATUS_OPTIMISTIC; //或运算保存状态
currentStatus |= STATUS_CLOSE;
System.out.println((currentStauts & STATUS_OPTIMISTIC) != 0);// 与运算判断状态,答案为true
System.out.println((currentStauts & STATUS_OPEN) != 0);// 答案为false
```
**与运算过程**:
```
00000101       00000101
00000001       00000010
---------      ---------
00000001       00000000
```
由于与运算的逻辑为两位数需要都为1，结果才为1，那么只有当状态中为1的那位与 currentStauts 中的那位结果都为1，与运算结果才会大于1。所以与运算可以用来判断是否有某个状态。

## 取出某个状态

> 取出某个状态使用 ^(异或) 操作

**取出某个状态的运算**:
```
private static int currentStatus = STATUS_DEFAULT; //此变量存储状态
currentStauts |= STATUS_OPTIMISTIC; //或运算保存状态
currentStatus |= STATUS_CLOSE;
currentStatus ^= STATUS_OPTIMISTIC; //异或运算取出状态
```
**或运算过程**:
```
00000101
00000001
---------
00000100
```

或运算会将两位数中不一样的结果置为1，那么当 currentStatus 想要取出某个状态时， 使用异或运算就能将状态所在的位置为1(因为如果 currentStatus中存在 STATUS_OPTIMISTIC 状态的话，两数在状态位上的二进制数都必定相同，都为1)

## 总结
由于位运算能够对状态进行方便的管理，即使在 java 线程池中也能经常见到许多位运算，例如ThreadPoolExecutor 源码中就使用位运算对线程池的运行状态以及线程有效数量进行管理。
